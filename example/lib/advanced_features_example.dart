import 'package:flutter/material.dart';
import 'package:flutter_mapbox_navigation/flutter_mapbox_navigation.dart';
import 'dart:math';
import 'dart:convert';

// Ë∑ØÁî±‰∫ã‰ª∂Êó•ÂøóÁ±ª
class RouteEventLog {
  final DateTime timestamp;
  final MapBoxEvent eventType;
  final String eventName;
  final dynamic data; // Êîπ‰∏∫ dynamic Á±ªÂûã‰ª•ÂåπÈÖç RouteEvent.data

  RouteEventLog({
    required this.timestamp,
    required this.eventType,
    required this.eventName,
    this.data,
  });

  String get formattedTime =>
    '${timestamp.hour.toString().padLeft(2, '0')}:'
    '${timestamp.minute.toString().padLeft(2, '0')}:'
    '${timestamp.second.toString().padLeft(2, '0')}';
}

class AdvancedFeaturesExample extends StatefulWidget {
  const AdvancedFeaturesExample({super.key});

  @override
  State<AdvancedFeaturesExample> createState() => _AdvancedFeaturesExampleState();
}

class _AdvancedFeaturesExampleState extends State<AdvancedFeaturesExample> {
  final List<WayPoint> _currentWayPoints = [];
  final List<List<WayPoint>> _routeHistory = [];
  final List<RouteEventLog> _eventLogs = [];
  MapBoxNavigationViewController? _controller;

  bool _isNavigating = false;
  String? _statusMessage;
  double? _totalDistance;

  @override
  void initState() {
    super.initState();
    _setupEventListeners();
  }

  void _setupEventListeners() {
    // ÁõëÂê¨ÂØºËà™‰∫ã‰ª∂
    MapBoxNavigation.instance.registerRouteEventListener(_onRouteEvent);
  }

  Future<void> _onRouteEvent(RouteEvent event) async {
    // ËÆ∞ÂΩï‰∫ã‰ª∂Êó•Âøó
    final eventLog = RouteEventLog(
      timestamp: DateTime.now(),
      eventType: event.eventType ?? MapBoxEvent.map_ready,
      eventName: _getEventName(event.eventType ?? MapBoxEvent.map_ready),
      data: event.data,
    );

    // ÊâìÂç∞Êó•Âøó
    debugPrint('üöó ÂØºËà™‰∫ã‰ª∂: ${eventLog.eventName} - ${eventLog.formattedTime}');
    if (event.data != null && _hasValidData(event.data)) {
      // ‰∏∫‰∏çÂêåÁ±ªÂûãÁöÑÊï∞ÊçÆÊèê‰æõÊõ¥ÊúâÁî®ÁöÑÊó•Âøó‰ø°ÊÅØ
      if (event.data is RouteProgressEvent) {
        final progress = event.data as RouteProgressEvent;
        debugPrint('üìä ÂØºËà™ËøõÂ∫¶: Ââ©‰Ωô${((progress.distance ?? 0) / 1000).toStringAsFixed(1)}km, '
                  'È¢ÑËÆ°${((progress.duration ?? 0) / 60).toStringAsFixed(0)}ÂàÜÈíü, '
                  'Êåá‰ª§: ${progress.currentStepInstruction ?? "Êó†"}');
      } else {
        debugPrint('üìä ‰∫ã‰ª∂Êï∞ÊçÆ: ${event.data}');
      }
    }

    setState(() {
      _eventLogs.insert(0, eventLog); // ÊúÄÊñ∞‰∫ã‰ª∂Âú®È°∂ÈÉ®
      // ÈôêÂà∂Êó•ÂøóÊï∞ÈáèÔºåÈÅøÂÖçÂÜÖÂ≠òËøáÂ§öÂç†Áî®
      if (_eventLogs.length > 100) {
        _eventLogs.removeRange(100, _eventLogs.length);
      }
    });

    // Â§ÑÁêÜÁâπÂÆö‰∫ã‰ª∂ÁöÑÁä∂ÊÄÅÊõ¥Êñ∞
    switch (event.eventType) {
      case MapBoxEvent.navigation_running:
        setState(() {
          _isNavigating = true;
          _statusMessage = "ÂØºËà™ËøõË°å‰∏≠...";
        });
        break;
      case MapBoxEvent.navigation_finished:
      case MapBoxEvent.navigation_cancelled:
        setState(() {
          _isNavigating = false;
          _statusMessage = "ÂØºËà™Â∑≤ÁªìÊùü";
        });
        break;
      case MapBoxEvent.on_arrival:
        setState(() {
          _statusMessage = "Â∑≤Âà∞ËææÁõÆÁöÑÂú∞";
        });
        break;
      case MapBoxEvent.route_building:
        setState(() {
          _statusMessage = "Ê≠£Âú®ËßÑÂàíË∑ØÁ∫ø...";
        });
        break;
      case MapBoxEvent.route_built:
        setState(() {
          _statusMessage = "Ë∑ØÁ∫øËßÑÂàíÂÆåÊàê";
        });
        break;
      case MapBoxEvent.progress_change:
        // ÂèØ‰ª•Âú®ËøôÈáåÊõ¥Êñ∞ËøõÂ∫¶‰ø°ÊÅØ
        if (event.data != null && event.data is RouteProgressEvent) {
          final progressEvent = event.data as RouteProgressEvent;
          final distance = progressEvent.distance;
          final duration = progressEvent.duration;
          if (distance != null && duration != null) {
            setState(() {
              _statusMessage = "Ââ©‰ΩôË∑ùÁ¶ª: ${(distance / 1000).toStringAsFixed(1)}km, "
                             "È¢ÑËÆ°Êó∂Èó¥: ${(duration / 60).toStringAsFixed(0)}ÂàÜÈíü";
            });
          }
        }
        break;
      default:
        break;
    }
  }

  // Ëé∑Âèñ‰∫ã‰ª∂ÂêçÁß∞ÁöÑËæÖÂä©ÊñπÊ≥ï
  String _getEventName(MapBoxEvent eventType) {
    switch (eventType) {
      case MapBoxEvent.map_ready:
        return 'Âú∞ÂõæÂáÜÂ§áÂ∞±Áª™';
      case MapBoxEvent.navigation_running:
        return 'ÂØºËà™ÂºÄÂßã';
      case MapBoxEvent.navigation_finished:
        return 'ÂØºËà™ÂÆåÊàê';
      case MapBoxEvent.navigation_cancelled:
        return 'ÂØºËà™ÂèñÊ∂à';
      case MapBoxEvent.on_arrival:
        return 'Âà∞ËææÁõÆÁöÑÂú∞';
      case MapBoxEvent.route_building:
        return 'Ë∑ØÁ∫øËßÑÂàí‰∏≠';
      case MapBoxEvent.route_built:
        return 'Ë∑ØÁ∫øËßÑÂàíÂÆåÊàê';
      case MapBoxEvent.route_build_failed:
        return 'Ë∑ØÁ∫øËßÑÂàíÂ§±Ë¥•';
      case MapBoxEvent.route_build_cancelled:
        return 'Ë∑ØÁ∫øËßÑÂàíÂèñÊ∂à';
      case MapBoxEvent.route_build_no_routes_found:
        return 'Êú™ÊâæÂà∞Ë∑ØÁ∫ø';
      case MapBoxEvent.progress_change:
        return 'ÂØºËà™ËøõÂ∫¶Êõ¥Êñ∞';
      case MapBoxEvent.user_off_route:
        return 'ÂÅèÁ¶ªË∑ØÁ∫ø';
      case MapBoxEvent.milestone_event:
        return 'ÈáåÁ®ãÁ¢ë‰∫ã‰ª∂';
      case MapBoxEvent.faster_route_found:
        return 'ÂèëÁé∞Êõ¥Âø´Ë∑ØÁ∫ø';
      case MapBoxEvent.speech_announcement:
        return 'ËØ≠Èü≥Êí≠Êä•';
      case MapBoxEvent.banner_instruction:
        return 'Ê®™ÂπÖÊåá‰ª§';
      case MapBoxEvent.failed_to_reroute:
        return 'ÈáçÊñ∞ËßÑÂàíÂ§±Ë¥•';
      case MapBoxEvent.reroute_along:
        return 'ÈáçÊñ∞ËßÑÂàíË∑ØÁ∫ø';
      case MapBoxEvent.on_map_tap:
        return 'Âú∞ÂõæÁÇπÂáª';
      case MapBoxEvent.history_recording_started:
        return 'ÂéÜÂè≤ËÆ∞ÂΩïÂºÄÂßã';
      case MapBoxEvent.history_recording_stopped:
        return 'ÂéÜÂè≤ËÆ∞ÂΩïÂÅúÊ≠¢';
      case MapBoxEvent.history_recording_error:
        return 'ÂéÜÂè≤ËÆ∞ÂΩïÈîôËØØ';
      default:
        return 'Êú™Áü•‰∫ã‰ª∂ (${eventType.toString()})';
    }
  }

  // Ëé∑Âèñ‰∫ã‰ª∂È¢úËâ≤ÁöÑËæÖÂä©ÊñπÊ≥ï
  Color _getEventColor(MapBoxEvent eventType) {
    switch (eventType) {
      case MapBoxEvent.navigation_running:
        return Colors.green;
      case MapBoxEvent.navigation_finished:
        return Colors.blue;
      case MapBoxEvent.navigation_cancelled:
        return Colors.red;
      case MapBoxEvent.on_arrival:
        return Colors.purple;
      case MapBoxEvent.route_building:
        return Colors.orange;
      case MapBoxEvent.route_built:
        return Colors.teal;
      case MapBoxEvent.route_build_failed:
        return Colors.red;
      case MapBoxEvent.progress_change:
        return Colors.lightBlue;
      case MapBoxEvent.user_off_route:
        return Colors.amber;
      case MapBoxEvent.faster_route_found:
        return Colors.indigo;
      case MapBoxEvent.speech_announcement:
        return Colors.deepPurple;
      case MapBoxEvent.banner_instruction:
        return Colors.cyan;
      case MapBoxEvent.history_recording_started:
        return Colors.green[700]!;
      case MapBoxEvent.history_recording_stopped:
        return Colors.grey;
      case MapBoxEvent.history_recording_error:
        return Colors.red[700]!;
      default:
        return Colors.grey;
    }
  }

  // Ëé∑Âèñ‰∫ã‰ª∂ÂõæÊ†áÁöÑËæÖÂä©ÊñπÊ≥ï
  IconData _getEventIcon(MapBoxEvent eventType) {
    switch (eventType) {
      case MapBoxEvent.navigation_running:
        return Icons.play_arrow;
      case MapBoxEvent.navigation_finished:
        return Icons.check_circle;
      case MapBoxEvent.navigation_cancelled:
        return Icons.cancel;
      case MapBoxEvent.on_arrival:
        return Icons.location_on;
      case MapBoxEvent.route_building:
        return Icons.route;
      case MapBoxEvent.route_built:
        return Icons.done;
      case MapBoxEvent.route_build_failed:
        return Icons.error;
      case MapBoxEvent.progress_change:
        return Icons.trending_up;
      case MapBoxEvent.user_off_route:
        return Icons.warning;
      case MapBoxEvent.faster_route_found:
        return Icons.flash_on;
      case MapBoxEvent.speech_announcement:
        return Icons.volume_up;
      case MapBoxEvent.banner_instruction:
        return Icons.info;
      case MapBoxEvent.history_recording_started:
        return Icons.fiber_manual_record;
      case MapBoxEvent.history_recording_stopped:
        return Icons.stop;
      case MapBoxEvent.history_recording_error:
        return Icons.error_outline;
      default:
        return Icons.help_outline;
    }
  }

  // ÊòæÁ§∫‰∫ã‰ª∂ËØ¶ÊÉÖÁöÑÊñπÊ≥ï
  void _showEventDetails(RouteEventLog log) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Row(
          children: [
            Icon(
              _getEventIcon(log.eventType),
              color: _getEventColor(log.eventType),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: Text(
                log.eventName,
                style: const TextStyle(fontSize: 16),
              ),
            ),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Êó∂Èó¥: ${log.formattedTime}'),
            const SizedBox(height: 8),
            Text('‰∫ã‰ª∂Á±ªÂûã: ${log.eventType.toString()}'),
            if (log.data != null) ...[
              const SizedBox(height: 8),
              const Text('‰∫ã‰ª∂Êï∞ÊçÆ:'),
              const SizedBox(height: 4),
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: Colors.grey[100],
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(
                  _formatEventData(log.data),
                  style: const TextStyle(
                    fontFamily: 'monospace',
                    fontSize: 12,
                  ),
                ),
              ),
            ],
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('ÂÖ≥Èó≠'),
          ),
        ],
      ),
    );
  }

  // Ê†ºÂºèÂåñ‰∫ã‰ª∂Êï∞ÊçÆÁöÑËæÖÂä©ÊñπÊ≥ï
  String _formatEventData(dynamic data) {
    if (data == null) return 'null';

    try {
      // Â¶ÇÊûúÊòØ RouteProgressEvent ÂØπË±°
      if (data is RouteProgressEvent) {
        final buffer = StringBuffer();
        buffer.writeln('üìç ÂØºËà™ËøõÂ∫¶‰ø°ÊÅØ:');
        buffer.writeln('- Ââ©‰ΩôË∑ùÁ¶ª: ${((data.distance ?? 0) / 1000).toStringAsFixed(1)} km');
        buffer.writeln('- È¢ÑËÆ°Êó∂Èó¥: ${((data.duration ?? 0) / 60).toStringAsFixed(0)} ÂàÜÈíü');
        buffer.writeln('- Â∑≤Ë°åÈ©∂: ${((data.distanceTraveled ?? 0) / 1000).toStringAsFixed(1)} km');
        buffer.writeln('- ÂΩìÂâçÊåá‰ª§: ${data.currentStepInstruction ?? "Êó†"}');
        buffer.writeln('- ÊòØÂê¶Âà∞Ëææ: ${data.arrived == true ? "ÊòØ" : "Âê¶"}');
        if (data.legIndex != null) {
          buffer.writeln('- Ë∑ØÊÆµÁ¥¢Âºï: ${data.legIndex}');
        }
        if (data.stepIndex != null) {
          buffer.writeln('- Ê≠•È™§Á¥¢Âºï: ${data.stepIndex}');
        }
        return buffer.toString().trim();
      }

      // Â¶ÇÊûúÊòØ WayPoint ÂØπË±°
      if (data is WayPoint) {
        return 'Ë∑ØÂæÑÁÇπ:\n'
               '- ÂêçÁß∞: ${data.name ?? 'N/A'}\n'
               '- Á∫¨Â∫¶: ${data.latitude?.toStringAsFixed(6) ?? 'N/A'}\n'
               '- ÁªèÂ∫¶: ${data.longitude?.toStringAsFixed(6) ?? 'N/A'}';
      }

      // Â¶ÇÊûúÊòØÂ≠óÁ¨¶‰∏≤ÔºåÂ∞ùËØïËß£Êûê‰∏∫ JSON
      if (data is String) {
        if (data.isEmpty) return '(Á©∫Â≠óÁ¨¶‰∏≤)';

        // Â∞ùËØïËß£Êûê JSON
        try {
          final decoded = jsonDecode(data);
          if (decoded is Map) {
            return _formatMapData(decoded);
          }
          return data;
        } catch (e) {
          // ‰∏çÊòØ JSONÔºåÁõ¥Êé•ËøîÂõûÂ≠óÁ¨¶‰∏≤
          return data;
        }
      }

      // Â¶ÇÊûúÊòØ Map
      if (data is Map) {
        return _formatMapData(data);
      }

      // ÂÖ∂‰ªñÁ±ªÂûãÔºåÁõ¥Êé•ËΩ¨Êç¢‰∏∫Â≠óÁ¨¶‰∏≤
      return data.toString();
    } catch (e) {
      return 'Êï∞ÊçÆÊ†ºÂºèÂåñÈîôËØØ: $e';
    }
  }

  // Ê†ºÂºèÂåñ Map Êï∞ÊçÆ
  String _formatMapData(Map data) {
    final buffer = StringBuffer();
    data.forEach((key, value) {
      buffer.writeln('- $key: $value');
    });
    return buffer.toString().trim();
  }

  // Ê£ÄÊü•Êï∞ÊçÆÊòØÂê¶ÊúâÊïàÔºà‰∏ç‰∏∫Á©∫‰∏îÊúâÂÜÖÂÆπÔºâ
  bool _hasValidData(dynamic data) {
    if (data == null) return false;

    // Â¶ÇÊûúÊòØÂ≠óÁ¨¶‰∏≤ÔºåÊ£ÄÊü•ÊòØÂê¶ÈùûÁ©∫
    if (data is String) {
      return data.isNotEmpty;
    }

    // Â¶ÇÊûúÊòØ RouteProgressEventÔºåÊÄªÊòØËÆ§‰∏∫ÊúâÊïàÔºàÂõ†‰∏∫ÂÆÉÂåÖÂê´ÂØºËà™‰ø°ÊÅØÔºâ
    if (data is RouteProgressEvent) {
      return true;
    }

    // Â¶ÇÊûúÊòØ WayPointÔºåÊ£ÄÊü•ÊòØÂê¶ÊúâÂùêÊ†á
    if (data is WayPoint) {
      return data.latitude != null && data.longitude != null;
    }

    // Â¶ÇÊûúÊòØ MapÔºåÊ£ÄÊü•ÊòØÂê¶ÈùûÁ©∫
    if (data is Map) {
      return data.isNotEmpty;
    }

    // Â¶ÇÊûúÊòØ ListÔºåÊ£ÄÊü•ÊòØÂê¶ÈùûÁ©∫
    if (data is List) {
      return data.isNotEmpty;
    }

    // ÂÖ∂‰ªñÁ±ªÂûãÔºåÊÄªÊòØËÆ§‰∏∫ÊúâÊïà
    return true;
  }



  // Ê∑ªÂä†È¢ÑËÆæÁöÑÁ§∫‰æãË∑ØÂæÑÁÇπ
  void _addSampleWayPoints() {
    setState(() {
      _currentWayPoints.clear();
      _currentWayPoints.addAll([
        WayPoint(name: "Âåó‰∫¨Á´ô", latitude: 39.9021, longitude: 116.4272),
        WayPoint(name: "Â§©ÂÆâÈó®ÂπøÂú∫", latitude: 39.9042, longitude: 116.4074),
        WayPoint(name: "ÊïÖÂÆ´ÂçöÁâ©Èô¢", latitude: 39.9163, longitude: 116.3972),
        WayPoint(name: "ÊôØÂ±±ÂÖ¨Âõ≠", latitude: 39.9239, longitude: 116.3979),
        WayPoint(name: "ÂåóÊµ∑ÂÖ¨Âõ≠", latitude: 39.9252, longitude: 116.3883),
      ]);
      _calculateTotalDistance();
    });
  }

  // ÁîüÊàêÈöèÊú∫Ë∑ØÂæÑÁÇπ
  void _generateRandomWayPoints() {
    final random = Random();
    const centerLat = 39.9042; // Â§©ÂÆâÈó®‰∏∫‰∏≠ÂøÉ
    const centerLon = 116.4074;
    const radiusKm = 5.0; // 5ÂÖ¨ÈáåÂçäÂæÑ
    const count = 5;

    final randomPoints = <WayPoint>[];
    for (int i = 0; i < count; i++) {
      // ÁîüÊàêÈöèÊú∫ËßíÂ∫¶ÂíåË∑ùÁ¶ª
      final angle = random.nextDouble() * 2 * pi;
      final distance = random.nextDouble() * radiusKm;

      // ËΩ¨Êç¢‰∏∫ÁªèÁ∫¨Â∫¶ÂÅèÁßª
      final latOffset = distance * cos(angle) / 111.0; // Â§ßÁ∫¶111kmÊØèÂ∫¶
      final lonOffset = distance * sin(angle) / (111.0 * cos(centerLat * pi / 180));

      randomPoints.add(WayPoint(
        name: "ÈöèÊú∫ÁÇπ${i + 1}",
        latitude: centerLat + latOffset,
        longitude: centerLon + lonOffset,
      ));
    }

    setState(() {
      _currentWayPoints.clear();
      _currentWayPoints.addAll(randomPoints);
      _calculateTotalDistance();
      _statusMessage = "Â∑≤ÁîüÊàê${randomPoints.length}‰∏™ÈöèÊú∫Ë∑ØÂæÑÁÇπ";
    });
  }

  // ‰ºòÂåñÂΩìÂâçË∑ØÁ∫ø
  void _optimizeCurrentRoute() {
    if (_currentWayPoints.length < 3) {
      setState(() {
        _statusMessage = "ÈúÄË¶ÅËá≥Â∞ë3‰∏™Ë∑ØÂæÑÁÇπÊâçËÉΩ‰ºòÂåñ";
      });
      return;
    }

    final optimizedPoints = _optimizeRoute(_currentWayPoints);
    setState(() {
      _currentWayPoints.clear();
      _currentWayPoints.addAll(optimizedPoints);
      _calculateTotalDistance();
      _statusMessage = "Ë∑ØÁ∫øÂ∑≤‰ºòÂåñÔºåÊÄªË∑ùÁ¶ª: ${_formatDistance(_totalDistance ?? 0)}";
    });
  }

  // ÁÆÄÂçïÁöÑË∑ØÁ∫ø‰ºòÂåñÁÆóÊ≥ïÔºàÊúÄËøëÈÇªÁÆóÊ≥ïÔºâ
  List<WayPoint> _optimizeRoute(List<WayPoint> wayPoints) {
    if (wayPoints.length < 2) return wayPoints;

    final optimizedPoints = <WayPoint>[];
    final remainingPoints = List<WayPoint>.from(wayPoints);

    // ‰ªéÁ¨¨‰∏Ä‰∏™ÁÇπÂºÄÂßã
    optimizedPoints.add(remainingPoints.removeAt(0));

    while (remainingPoints.isNotEmpty) {
      final currentPoint = optimizedPoints.last;
      double minDistance = double.infinity;
      int nearestIndex = 0;

      for (int i = 0; i < remainingPoints.length; i++) {
        final distance = _calculateDistance(
          currentPoint.latitude!,
          currentPoint.longitude!,
          remainingPoints[i].latitude!,
          remainingPoints[i].longitude!,
        );

        if (distance < minDistance) {
          minDistance = distance;
          nearestIndex = i;
        }
      }

      optimizedPoints.add(remainingPoints.removeAt(nearestIndex));
    }

    return optimizedPoints;
  }

  // ËÆ°ÁÆóÊÄªË∑ùÁ¶ª
  void _calculateTotalDistance() {
    if (_currentWayPoints.length < 2) {
      _totalDistance = 0;
      return;
    }

    double total = 0;
    for (int i = 0; i < _currentWayPoints.length - 1; i++) {
      total += _calculateDistance(
        _currentWayPoints[i].latitude!,
        _currentWayPoints[i].longitude!,
        _currentWayPoints[i + 1].latitude!,
        _currentWayPoints[i + 1].longitude!,
      );
    }
    _totalDistance = total;
  }

  // ËÆ°ÁÆó‰∏§ÁÇπÈó¥Ë∑ùÁ¶ªÔºàHaversineÂÖ¨ÂºèÔºâ
  double _calculateDistance(double lat1, double lon1, double lat2, double lon2) {
    const double earthRadius = 6371000; // Âú∞ÁêÉÂçäÂæÑÔºàÁ±≥Ôºâ

    final double dLat = (lat2 - lat1) * pi / 180;
    final double dLon = (lon2 - lon1) * pi / 180;

    final double a = sin(dLat / 2) * sin(dLat / 2) +
        cos(lat1 * pi / 180) * cos(lat2 * pi / 180) *
        sin(dLon / 2) * sin(dLon / 2);

    final double c = 2 * atan2(sqrt(a), sqrt(1 - a));

    return earthRadius * c;
  }

  // Ê†ºÂºèÂåñË∑ùÁ¶ªÊòæÁ§∫
  String _formatDistance(double meters) {
    if (meters < 1000) {
      return "${meters.toStringAsFixed(0)}Á±≥";
    } else {
      return "${(meters / 1000).toStringAsFixed(2)}ÂÖ¨Èáå";
    }
  }

  // ËÆ°ÁÆóÊåáÂÆöË∑ØÁ∫øÁöÑÊÄªË∑ùÁ¶ª
  double _calculateTotalDistanceForRoute(List<WayPoint> wayPoints) {
    if (wayPoints.length < 2) return 0;

    double total = 0;
    for (int i = 0; i < wayPoints.length - 1; i++) {
      total += _calculateDistance(
        wayPoints[i].latitude!,
        wayPoints[i].longitude!,
        wayPoints[i + 1].latitude!,
        wayPoints[i + 1].longitude!,
      );
    }
    return total;
  }

  // È™åËØÅË∑ØÂæÑÁÇπ
  bool _validateWayPoints(List<WayPoint> wayPoints) {
    if (wayPoints.length < 2) {
      setState(() {
        _statusMessage = "Ëá≥Â∞ëÈúÄË¶Å2‰∏™Ë∑ØÂæÑÁÇπÊâçËÉΩÂºÄÂßãÂØºËà™";
      });
      return false;
    }

    for (int i = 0; i < wayPoints.length; i++) {
      final wayPoint = wayPoints[i];
      if (wayPoint.latitude == null || wayPoint.longitude == null) {
        setState(() {
          _statusMessage = "Ë∑ØÂæÑÁÇπ${i + 1}ÁöÑÂùêÊ†áÊó†Êïà";
        });
        return false;
      }
    }

    return true;
  }

  // ‰øùÂ≠òÂΩìÂâçË∑ØÁ∫ø
  void _saveCurrentRoute() {
    if (_currentWayPoints.isEmpty) {
      setState(() {
        _statusMessage = "Ê≤°ÊúâË∑ØÁ∫øÂèØ‰øùÂ≠ò";
      });
      return;
    }

    // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ≠òÂú®Áõ∏ÂêåÁöÑË∑ØÁ∫ø
    bool isDuplicate = false;
    for (var existingRoute in _routeHistory) {
      if (existingRoute.length == _currentWayPoints.length) {
        bool same = true;
        for (int i = 0; i < existingRoute.length; i++) {
          if (existingRoute[i].latitude != _currentWayPoints[i].latitude ||
              existingRoute[i].longitude != _currentWayPoints[i].longitude) {
            same = false;
            break;
          }
        }
        if (same) {
          isDuplicate = true;
          break;
        }
      }
    }

    if (isDuplicate) {
      setState(() {
        _statusMessage = "Ê≠§Ë∑ØÁ∫øÂ∑≤Â≠òÂú®‰∫éÂéÜÂè≤ËÆ∞ÂΩï‰∏≠";
      });
      return;
    }

    _routeHistory.add(List<WayPoint>.from(_currentWayPoints));
    setState(() {
      _statusMessage = "Ë∑ØÁ∫øÂ∑≤‰øùÂ≠òÂà∞ÂéÜÂè≤ËÆ∞ÂΩïÔºà${_currentWayPoints.length}‰∏™ÁÇπÔºåÂÖ±${_routeHistory.length}Êù°ÂéÜÂè≤Ôºâ";
    });

    // Ê∑ªÂä†Ë∞ÉËØï‰ø°ÊÅØ
    print('Ë∑ØÁ∫øÂ∑≤‰øùÂ≠òÔºåÂéÜÂè≤ËÆ∞ÂΩïÊï∞Èáè: ${_routeHistory.length}');

    // ÊòæÁ§∫ÊàêÂäüÊèêÁ§∫
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Ë∑ØÁ∫øÂ∑≤‰øùÂ≠òÔºÅÂΩìÂâçÂÖ±Êúâ${_routeHistory.length}Êù°ÂéÜÂè≤ËÆ∞ÂΩï'),
        backgroundColor: Colors.green,
        duration: const Duration(seconds: 2),
        action: SnackBarAction(
          label: 'Êü•Áúã',
          textColor: Colors.white,
          onPressed: _showRouteHistory,
        ),
      ),
    );
  }

  // ÊòæÁ§∫Ë∑ØÁ∫øÂéÜÂè≤
  void _showRouteHistory() {
    final history = _routeHistory;

    // Ê∑ªÂä†Ë∞ÉËØï‰ø°ÊÅØ
    print('ÊòæÁ§∫ÂéÜÂè≤ËÆ∞ÂΩïÔºåÂΩìÂâçÂéÜÂè≤Êï∞Èáè: ${history.length}');

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Ë∑ØÁ∫øÂéÜÂè≤ËÆ∞ÂΩï (${history.length}Êù°)'),
        content: SizedBox(
          width: double.maxFinite,
          height: 300,
          child: history.isEmpty
            ? const Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.history, size: 64, color: Colors.grey),
                  SizedBox(height: 16),
                  Text('ÊöÇÊó†ÂéÜÂè≤ËÆ∞ÂΩï'),
                  SizedBox(height: 8),
                  Text(
                    'ÂÖàÊ∑ªÂä†‰∏Ä‰∫õË∑ØÂæÑÁÇπÔºåÁÑ∂ÂêéÁÇπÂáª"‰øùÂ≠òË∑ØÁ∫ø"',
                    style: TextStyle(fontSize: 12, color: Colors.grey),
                    textAlign: TextAlign.center,
                  ),
                ],
              )
            : ListView.builder(
                itemCount: history.length,
                itemBuilder: (context, index) {
                  final route = history[index];
                  final distance = _calculateTotalDistanceForRoute(route);

                  return Card(
                    child: ListTile(
                      leading: CircleAvatar(
                        backgroundColor: Colors.blue,
                        child: Text('${index + 1}'),
                      ),
                      title: Text('Ë∑ØÁ∫ø ${index + 1}'),
                      subtitle: Text(
                        '${route.length}‰∏™Ë∑ØÂæÑÁÇπ - ${_formatDistance(distance)}'
                      ),
                      trailing: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          IconButton(
                            icon: const Icon(Icons.restore, color: Colors.green),
                            tooltip: 'ÊÅ¢Â§çÊ≠§Ë∑ØÁ∫ø',
                            onPressed: () {
                              setState(() {
                                _currentWayPoints.clear();
                                _currentWayPoints.addAll(route);
                                _calculateTotalDistance();
                                _statusMessage = "Â∑≤ÊÅ¢Â§çË∑ØÁ∫ø ${index + 1}";
                              });
                              Navigator.of(context).pop();
                            },
                          ),
                          IconButton(
                            icon: const Icon(Icons.delete, color: Colors.red),
                            tooltip: 'Âà†Èô§Ê≠§Ë∑ØÁ∫ø',
                            onPressed: () {
                              setState(() {
                                _routeHistory.removeAt(index);
                              });
                              Navigator.of(context).pop();
                              _showRouteHistory(); // ÈáçÊñ∞ÊòæÁ§∫ÂØπËØùÊ°Ü
                            },
                          ),
                        ],
                      ),
                    ),
                  );
                },
              ),
        ),
        actions: [
          TextButton(
            onPressed: () {
              setState(() {
                _routeHistory.clear();
              });
              Navigator.of(context).pop();
            },
            child: const Text('Ê∏ÖÈô§ÂéÜÂè≤'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('ÂÖ≥Èó≠'),
          ),
        ],
      ),
    );
  }

  // ÊêúÁ¥¢Âπ∂ÂØºËà™
  Future<void> _searchAndNavigate() async {
    try {
      setState(() {
        _statusMessage = "Ê≠£Âú®ÊâìÂºÄÊêúÁ¥¢ÁïåÈù¢...";
      });

      // ÊòæÁ§∫ÊêúÁ¥¢ÁïåÈù¢Âπ∂Ëé∑ÂèñwayPointsÊï∞ÁªÑ
      final wayPointsData = await MapboxSearch.showSearchView();

      if (wayPointsData != null && wayPointsData.isNotEmpty) {
        // Â∞ÜÊêúÁ¥¢ÁªìÊûúËΩ¨Êç¢‰∏∫WayPointÂØπË±°
        final List<WayPoint> wayPoints = wayPointsData.map((data) {
          return WayPoint(
            name: data['name'] as String? ?? 'Êú™Áü•‰ΩçÁΩÆ',
            latitude: (data['latitude'] as num?)?.toDouble(),
            longitude: (data['longitude'] as num?)?.toDouble(),
            isSilent: data['isSilent'] as bool? ?? false,
          );
        }).toList();

        // Êõ¥Êñ∞ÂΩìÂâçË∑ØÂæÑÁÇπ
        setState(() {
          _currentWayPoints.clear();
          _currentWayPoints.addAll(wayPoints);
          _calculateTotalDistance();
          _statusMessage = "Â∑≤Ê∑ªÂä†${wayPoints.length}‰∏™Ë∑ØÂæÑÁÇπÔºåÂáÜÂ§áÂºÄÂßãÂØºËà™";
        });

        // Â¶ÇÊûúÊúâË∂≥Â§üÁöÑË∑ØÂæÑÁÇπÔºåÁõ¥Êé•ÂºÄÂßãÂØºËà™
        if (wayPoints.length >= 2) {
          await _startNavigation();
        } else {
          setState(() {
            _statusMessage = "ÈúÄË¶ÅËá≥Â∞ë2‰∏™Ë∑ØÂæÑÁÇπÊâçËÉΩÂºÄÂßãÂØºËà™";
          });
        }
      } else {
        setState(() {
          _statusMessage = "Êú™ÈÄâÊã©‰ªª‰Ωï‰ΩçÁΩÆ";
        });
      }
    } catch (e) {
      setState(() {
        _statusMessage = "ÊêúÁ¥¢ÂØºËà™Â§±Ë¥•: $e";
      });
      debugPrint('ÊêúÁ¥¢ÂØºËà™ÈîôËØØ: $e');
    }
  }

  // Ê∏ÖÈô§ÊâÄÊúâË∑ØÂæÑÁÇπ
  void _clearWayPoints() {
    setState(() {
      _currentWayPoints.clear();
      _totalDistance = null;
      _statusMessage = "Â∑≤Ê∏ÖÈô§ÊâÄÊúâË∑ØÂæÑÁÇπ";
    });
  }

  // Ê∏ÖÈô§‰∫ã‰ª∂Êó•Âøó
  void _clearEventLogs() {
    setState(() {
      _eventLogs.clear();
      _statusMessage = "Â∑≤Ê∏ÖÈô§‰∫ã‰ª∂Êó•Âøó";
    });
  }

  // ÂºÄÂßãÂØºËà™
  Future<void> _startNavigation() async {
    if (!_validateWayPoints(_currentWayPoints)) {
      return;
    }

    try {
      final options = MapBoxOptions(
        mode: MapBoxNavigationMode.cycling,
        simulateRoute: true,
        language: "zh-CN",
        units: VoiceUnits.metric,
        voiceInstructionsEnabled: true,
        bannerInstructionsEnabled: true,
        enableHistoryRecording: true
      );

      await MapBoxNavigation.instance.startNavigation(
        wayPoints: _currentWayPoints,
        options: options,
      );
    } catch (e) {
      setState(() {
        _statusMessage = "ÂØºËà™ÂêØÂä®Â§±Ë¥•: $e";
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('È´òÁ∫ßÂäüËÉΩÁ§∫‰æã'),
        backgroundColor: Colors.green,
      ),
      body: Column(
        children: [
          // Áä∂ÊÄÅÈù¢Êùø
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(16),
            color: Colors.grey[100],
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'ÂΩìÂâçË∑ØÂæÑÁÇπ: ${_currentWayPoints.length}‰∏™',
                  style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                ),
                if (_totalDistance != null)
                  Text('ÊÄªË∑ùÁ¶ª: ${_formatDistance(_totalDistance!)}'),
                if (_statusMessage != null)
                  Text('Áä∂ÊÄÅ: $_statusMessage'),
              ],
            ),
          ),

          // ÂäüËÉΩÊåâÈíÆÁªÑ
          Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              children: [
                // Á¨¨‰∏ÄË°åÊåâÈíÆ
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    ElevatedButton(
                      onPressed: _addSampleWayPoints,
                      child: const Text('Á§∫‰æãË∑ØÁ∫ø'),
                    ),
                    ElevatedButton(
                      onPressed: _generateRandomWayPoints,
                      child: const Text('ÈöèÊú∫Ë∑ØÁ∫ø'),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                
                // Á¨¨‰∫åË°åÊåâÈíÆ
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    ElevatedButton(
                      onPressed: _currentWayPoints.length >= 3 ? _optimizeCurrentRoute : null,
                      child: const Text('‰ºòÂåñË∑ØÁ∫ø'),
                    ),
                    ElevatedButton(
                      onPressed: _currentWayPoints.isNotEmpty ? _saveCurrentRoute : null,
                      child: const Text('‰øùÂ≠òË∑ØÁ∫ø'),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                
                // Á¨¨‰∏âË°åÊåâÈíÆ
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    ElevatedButton(
                      onPressed: _showRouteHistory,
                      child: const Text('ÂéÜÂè≤ËÆ∞ÂΩï'),
                    ),
                    ElevatedButton(
                      onPressed: !_isNavigating ? _searchAndNavigate : null,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.orange,
                        foregroundColor: Colors.white,
                      ),
                      child: const Text('ÊêúÁ¥¢ÂØºËà™'),
                    ),
                  ],
                ),
                const SizedBox(height: 8),

                // Á¨¨ÂõõË°åÊåâÈíÆ
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    ElevatedButton(
                      onPressed: _currentWayPoints.length >= 2 && !_isNavigating
                        ? _startNavigation
                        : null,
                      child: const Text('ÂºÄÂßãÂØºËà™'),
                    ),
                    ElevatedButton(
                      onPressed: _currentWayPoints.isNotEmpty ? _clearWayPoints : null,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.red,
                        foregroundColor: Colors.white,
                      ),
                      child: const Text('Ê∏ÖÈô§Ë∑ØÁ∫ø'),
                    ),
                  ],
                ),
              ],
            ),
          ),

          // Ë∑ØÂæÑÁÇπÂàóË°®Âíå‰∫ã‰ª∂Êó•Âøó - ‰∏ä‰∏ãÊéíÂàó
          Expanded(
            child: Column(
              children: [
                // Ë∑ØÂæÑÁÇπÂàóË°® (‰∏äÂçäÈÉ®ÂàÜ)
                Expanded(
                  flex: 1,
                  child: Container(
                    margin: const EdgeInsets.symmetric(horizontal: 16),
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.grey),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Column(
                      children: [
                        Container(
                          width: double.infinity,
                          padding: const EdgeInsets.all(12),
                          decoration: const BoxDecoration(
                            color: Colors.blue,
                            borderRadius: BorderRadius.only(
                              topLeft: Radius.circular(8),
                              topRight: Radius.circular(8),
                            ),
                          ),
                          child: const Text(
                            'ÂΩìÂâçË∑ØÂæÑÁÇπ',
                            style: TextStyle(
                              color: Colors.white,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                        Expanded(
                          child: _currentWayPoints.isEmpty
                            ? const Center(
                                child: Text('ÊöÇÊó†Ë∑ØÂæÑÁÇπ\nÁÇπÂáª‰∏äÊñπÊåâÈíÆÊ∑ªÂä†Ë∑ØÁ∫ø'),
                              )
                            : ListView.builder(
                                itemCount: _currentWayPoints.length,
                                itemBuilder: (context, index) {
                                  final wayPoint = _currentWayPoints[index];
                                  return ListTile(
                                    leading: CircleAvatar(
                                      backgroundColor: index == 0
                                        ? Colors.green
                                        : index == _currentWayPoints.length - 1
                                          ? Colors.red
                                          : Colors.blue,
                                      child: Text('${index + 1}'),
                                    ),
                                    title: Text(wayPoint.name ?? 'Ë∑ØÂæÑÁÇπ ${index + 1}'),
                                    subtitle: Text(
                                      '${wayPoint.latitude?.toStringAsFixed(4) ?? 'N/A'}, ${wayPoint.longitude?.toStringAsFixed(4) ?? 'N/A'}'
                                    ),
                                    trailing: IconButton(
                                      icon: const Icon(Icons.delete),
                                      onPressed: () {
                                        setState(() {
                                          _currentWayPoints.removeAt(index);
                                          _calculateTotalDistance();
                                        });
                                      },
                                    ),
                                  );
                                },
                              ),
                        ),
                      ],
                    ),
                  ),
                ),

                const SizedBox(height: 8), // Èó¥Ë∑ù

                // ‰∫ã‰ª∂Êó•ÂøóÂàóË°® (‰∏ãÂçäÈÉ®ÂàÜ)
                Expanded(
                  flex: 1,
                  child: Container(
                    margin: const EdgeInsets.symmetric(horizontal: 16),
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.grey),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Column(
                      children: [
                        Container(
                          width: double.infinity,
                          padding: const EdgeInsets.all(12),
                          decoration: const BoxDecoration(
                            color: Colors.green,
                            borderRadius: BorderRadius.only(
                              topLeft: Radius.circular(8),
                              topRight: Radius.circular(8),
                            ),
                          ),
                          child: Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              const Text(
                                'ÂØºËà™‰∫ã‰ª∂Êó•Âøó',
                                style: TextStyle(
                                  color: Colors.white,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                              Row(
                                children: [
                                  Text(
                                    '${_eventLogs.length}',
                                    style: const TextStyle(
                                      color: Colors.white,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                  const SizedBox(width: 8),
                                  GestureDetector(
                                    onTap: _clearEventLogs,
                                    child: const Icon(
                                      Icons.clear_all,
                                      color: Colors.white,
                                      size: 20,
                                    ),
                                  ),
                                ],
                              ),
                            ],
                          ),
                        ),
                        Expanded(
                          child: _eventLogs.isEmpty
                            ? const Center(
                                child: Text('ÊöÇÊó†‰∫ã‰ª∂Êó•Âøó\nÂºÄÂßãÂØºËà™Âêé‰ºöÊòæÁ§∫‰∫ã‰ª∂'),
                              )
                            : ListView.builder(
                                itemCount: _eventLogs.length,
                                itemBuilder: (context, index) {
                                  final log = _eventLogs[index];
                                  return ListTile(
                                    dense: true,
                                    leading: CircleAvatar(
                                      radius: 12,
                                      backgroundColor: _getEventColor(log.eventType),
                                      child: Icon(
                                        _getEventIcon(log.eventType),
                                        size: 16,
                                        color: Colors.white,
                                      ),
                                    ),
                                    title: Text(
                                      log.eventName,
                                      style: const TextStyle(fontSize: 12),
                                    ),
                                    subtitle: Text(
                                      log.formattedTime,
                                      style: const TextStyle(fontSize: 10),
                                    ),
                                    onTap: () => _showEventDetails(log),
                                  );
                                },
                              ),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
          
          const SizedBox(height: 16),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _controller?.dispose();
    super.dispose();
  }
}
